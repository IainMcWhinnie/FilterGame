msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Jul 17 22:28:41 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Sets are subsets of themselves"
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "If `S` and `T` are sets, then `S ‚äÜ T` means that `S` is a *subset* of `T`.\n"
"This means that every element of `S` is also an element of `T`. Let me talk you through\n"
"a proof that `S ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"If `h` is a proof of an implication `X ‚Üî Y` or an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"### Example:\n"
"\n"
"If your goal is\n"
"```\n"
"A ‚äÜ B\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [subset_def]`\n"
"\n"
"will change the goal into `‚àÄ x ‚àà A, x ‚àà B`.\n"
"\n"
"## Variants\n"
"\n"
"Say `h : X = Y` or `h : X ‚Üî Y`.\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [subset_def]` will change all `S ‚äÜ T`s into their definitions,\n"
"until there are no more matches.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `X = Y`)\n"
"or a *bi-implication* (a statement of the form `X ‚Üî Y`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`'s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `subset_def`\n"
"is really a proof that `?‚ÇÅ ‚äÜ ?‚ÇÇ ‚Üî ‚àÄ x ‚àà ?‚ÇÅ, x ‚àà ?‚ÇÇ`,\n"
"or, if you like, a proof that `‚àÄ S T, S ‚äÜ T ‚Üî ‚àÄ x ‚àà S, x ‚àà T` because `subset_def` really\n"
"is a function, with `S` and `T` the inputs.\n"
"In this situation `rw` will look through the goal\n"
"for any subterm of the form `?‚ÇÅ ‚äÜ ?‚ÇÇ`, and the moment it\n"
"finds a match it solves for the `?`s (e.g. `?‚ÇÅ = A` and `?‚ÇÇ = B`) and then\n"
"then changes all `A ‚äÜ B`s to `‚àÄ x ‚àà A, x ‚àà B`s.\n"
"\n"
"If you can't remember the *name* of the proof of an equality or bi-implication, look it up in\n"
"the list of lemmas on the right."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"If the goal is `‚àÄ x, P x`, this mean that you have to prove something for every `x`.\n"
"A mathematician might say \"Now let `x` be arbitrary\". In Lean we say `intro x`.\n"
"This will change the goal to `P x`. Note we could equally say `intro fish`,\n"
"which would change the goal to `P fish`.\n"
"\n"
"If the goal is `P ‚Üí Q`, then `intro h` will introduce `h : P` as a hypothesis,\n"
"and change the goal to `Q`. Mathematically, it says that to prove $P \\implies Q$,\n"
"we can assume $P$ and then prove $Q$.\n"
"\n"
"### Example:\n"
"\n"
"If your goal is `‚àÄ x ‚àà S, x ‚àà T` then `intro a` will give you a new variable `a`\n"
"and the goal will become `a ‚àà S ‚Üí a ‚àà T`. A second `intro h` will now give you the\n"
"hypothesis `h : a ‚àà S`, and the goal will change to `a ‚àà T`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"This tactic has two distinct uses.\n"
"\n"
"1) If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"2) If your goal is a special case of a theorem `P` (for example perhaps `P` says\n"
"\"for all `x`, ...\" and your goal has a specific example of an `x`),\n"
"then `apply P` will attempt to figure out all the variable substitutions necessary\n"
"to close the goal.\n"
"\n"
"### Example:\n"
"\n"
"**TODO** more appropriate examples.\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will close the goal if `h` is a proof of `P`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x ‚àà S` and you have a hypothesis `h : x ‚àà S`\n"
"then `exact h` will solve the goal.\n"
"\n"
"### Non-example\n"
"\n"
"If the goal is `x ‚àà S`, then `exact x ‚àà S` won't work. Exact eats a *proof*\n"
"of a mathematical result, not a *statement*.\n"
"\n"
"### Exact needs to be exactly right\n"
"\n"
"**TODO** do `apply` example for `mem_univ` or whatever.\n"
"\n"
"Note that `exact add_zero` will *not work* in the previous example;\n"
"for `exact h` to work, `h` has to be *exactly* a proof of the goal.\n"
"`add_zero` is a proof of `‚àÄ n, n + 0 = n` or, if you like,\n"
"a proof of `? + 0 = ?` where `?` needs to be supplied by the user.\n"
"This is in contrast to `rw` and `apply`, which will \\\"guess the inputs\\\"\n"
"if necessary. If the goal is `x + 0 = x` then `rw [add_zero]`\n"
"and `rw [add_zero x]` will both change the goal to `x = x`,\n"
"because `rw` guesses the input to the function `add_zero`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "`subset_def` is the proof of `(S ‚äÜ T) ‚Üî ‚àÄ x, x ‚àà S ‚Üí x ‚àà T`.\n"
"\n"
"If you're working with subsets from first principles, then `rw [subset_def]`\n"
"will change occurrences of `S ‚äÜ T` in the goal to `‚àÄ x, x ‚àà S ‚Üí x ‚àà T`.\n"
"\n"
"Variants:\n"
"\n"
"* `rw [subset_def] at h` (change the definition at hypothesis `h`)\n"
"* `rw [subset_def] at *` (change the definition everywhere)"
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Every set $S$ is a subset of itself."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Every set $S$ is a subset of itself."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Start with `rw [subset_def]` to replace `S ‚äÜ S` with its definition."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Now we've got to prove something for all `x`, so `intro x`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Now we assume `x ‚àà S` with `intro h`"
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "And now our goal is exactly `h`, so `exact h` or `apply h` will finish the level."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Nice! Let's now prove another basic property of subsets."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Set inclusion is transitive"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "In this level, we'll show the \"geometrically obvious\"\n"
"fact that if `S`, `T` and `U` are sets, with `S ‚äÜ T`\n"
"and `T ‚äÜ U`, then `S ‚äÜ U`."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "If $S ‚äÜ T$ and $T\\subseteq U$ then $S\\subseteq U$."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "If $S ‚äÜ T$ and $T\\subseteq U$ then $S\\subseteq U$."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Start with `rw [subset_def] at *` to replace all occurences of the `‚äÜ` symbol with\n"
"their definitions."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now we've got to prove something for all `x`, so `intro x`."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now we assume `x ‚àà S` with `intro h`"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now we just have to put the pieces together.\n"
"You can either argue forwards, with `apply hST at h`,\n"
"or you can argue backwards with `apply hTU`."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now figure out how to use `hTU` to finish things off."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "`apply hTU at h` or `apply hTU` make progress. Then `exact h`"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now figure out how to use `hST` to finish things off."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "`apply hST at h` or `apply hST` make progress. Then `exact h`"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Nice! Let's now prove another basic property of subsets."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "Set inclusion is antisymmetric"
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "The subset relation `‚äÜ` is a *partial order*. This means that it's reflexive,\n"
"transitive, and antisymmetric. In this level we learn two new tactics\n"
"to prove that if `S ‚äÜ T` and `T ‚äÜ S` then `S = T`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "## Summary\n"
"\n"
"If the goal is really two goals, for example `P ‚Üî Q` or `P ‚àß Q`, then `constructor`\n"
"it into two different goals.\n"
"\n"
"### Example\n"
"\n"
"`constructor` turns the goal `P ‚Üî Q` into the two goals `P ‚Üí Q` and `Q ‚Üí P`.\n"
"\n"
"### Example\n"
"\n"
"`constructor` turns the goal `P ‚àß Q` into the two goals `P` and `Q`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "## Summary\n"
"\n"
"If the goal is the equaality of two sets `S = T`, then `ext a` introduces a new variable `a`\n"
"and turns the goal into `a ‚àà S ‚Üî a ‚àà T`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "If $S ‚äÜ T$ and $T\\subseteq S$ then $S = T$."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "If $S ‚äÜ T$ and $T\\subseteq S$ then $S = T$."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "We have to prove that two sets are equal. It's an axiom of mathematics\n"
"(\"set extensionality\") that two sets are equal if they have the same elements.\n"
"In Lean the `ext` tactic applies this axiom. Start with `ext a`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "We now have to prove an if and only if statement `P ‚Üî Q`, which is the same as proving\n"
"`P ‚Üí Q` and `Q ‚Üí P`. Now use the `constructor` tactic to split the goal up into these two goals."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "This goal is going to follow from the fact that `S ‚äÜ T`. So let's `rw [subset_def] at hST`\n"
"to get it into a more useful form"
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "You've seen this kind of goal before in the previous level. See if you can take it from here."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "Now we have to go the other way. Here's a quick approach: try `apply hTS`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "Did you solve `a ‚àà T ‚Üí a ‚àà S` with one tactic `apply hTS`? The reason this works\n"
"is that `T ‚äÜ S` is equal to `‚àÄ x, x ‚àà T ‚Üí x ‚àà S` *by definition*, so it is a theorem which\n"
"applies for all `x`, and in particular it applies for `x = a`, which is the goal."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "The \"universal set\""
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "Every set in this world is a subset of `ùìß`, but `ùìß` is a *type*, not a set.\n"
"So what is the set which contains every element of `ùìß`? It's called `univ`. And\n"
"the axiom you need to know is `mem_univ (x : ùìß) : x ‚àà univ`. You should `apply mem_univ`\n"
"when faced with the goal `x ‚àà univ`."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "`mem_univ` is the proof of `‚àÄ x, x ‚àà univ`.\n"
"\n"
"When faced with a goal `a ‚àà univ`, you can `apply mem_univ` to close it. You can\n"
"also do `exact mem_univ a`."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "Any set `S` satisfies `S ‚äÜ univ`."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "If $S ‚äÜ T$ and $T\\subseteq S$ then $S = T$."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "Try and the turn the goal into `x ‚àà univ` and then `apply mem_univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Nothing's bigger than the universal set"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "See if you can use the tactics we've learnt to prove that if `univ ‚äÜ S`\n"
"then `S = univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "`univ_subset` is the proof that `univ ‚äÜ S ‚Üí S = univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Any set `S` satisfies `S ‚äÜ univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "If $univ ‚äÜ S$ then $S = univ$."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Start with `intro h`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `rw [subset_def] at h`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `ext a`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `constructor`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `intro h2`"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `apply mem_univ`"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Can you finish in one line?"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `apply ¬´{h}¬ª`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Intersections"
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "The last thing we need to know about subsets is how to work with the intersection\n"
"`S ‚à© T` of two subsets `S` and `T`. The key lemma you need is\n"
"`mem_inter_iff x S T`, which is a proof of `x ‚àà S ‚à© T ‚Üî x ‚àà S ‚àß x ‚àà T`. That `‚àß` symbol\n"
"means \"and\"."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "## Summary\n"
"\n"
"If the goal is a true statement in pure logic, like `P ‚Üí (Q ‚Üí P)` or `P ‚àß Q ‚Üí Q ‚àß P`\n"
"(where `P` and `Q` can represent any mathematical true/false statements) then\n"
"the `tauto` tactic will solve it."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "`mem_inter_iff` is the proof of `‚àÄ x S T, x ‚àà S ‚à© T ‚Üî x ‚àà S ‚àß x ‚àà T`.\n"
"\n"
"Note that `mem_inter_iff` has three explicit inputs, `x`, `S` and `T`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "`S ‚à© T = T ‚à© S`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "`S ‚à© T = T ‚à© S`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Start with `ext a`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Now `rw [mem_inter_iff]`"
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Now do it again, and the goal will be purely a logic goal."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "This has now got nothing to do with sets. Prove this logic goal with `tauto`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "`S ‚à© T ‚äÜ S`"
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Let's prove `inter_subset_left`, the statement that `S ‚à© T ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "## Summary\n"
"\n"
"If the goal is a true statement in pure logic, like `P ‚Üí (Q ‚Üí P)` or `P ‚àß Q ‚Üí Q ‚àß P`\n"
"(where `P` and `Q` can represent any mathematical true/false statements) then\n"
"the `tauto` tactic will solve it."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "`S ‚à© T ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "`S ‚à© T ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "There's a subtlety here, so let me talk you through it. Start of course with\n"
"`rw [subset_def]`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Now you can see `x ‚àà S ‚à© T` in the goal, but `rw [mem_inter_iff]` will *fail*, because\n"
"\"`rw` doesn't work under binders\". In other words, that `x` isn't a variable yet,\n"
"it's a \"for all `x`\". Make it a variable with `intro x`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Now you have an actual `x : ùìß` in your list of variables, so `rw [mem_inter_iff]` will\n"
"work."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Now finish this pure logic goal in one line."
msgstr ""

#: Game.Levels.SetWorld
msgid "Set World"
msgstr ""

#: Game.Levels.SetWorld
msgid "In this tutorial level we'll learn about sets, subsets, and the intersection of two sets.\n"
"\n"
"Our sets will all be subsets of a fixed \"base set\" `ùìß`.\n"
"In particular, whenever we say \"let `S` be a set\" in this level, we mean \"let `S` be a set\n"
"of elements of `ùìß`\", and we write `S : Set ùìß`.\n"
"\n"
"In Lean the base set `ùìß` is called a *type*. If you're used to also thinking of `ùìß` as a set,\n"
"this shouldn't cause any problems, but there is one notational difference. Lean uses the notation\n"
"`x : ùìß` to mean that `x` is an element of the base type `ùìß`, but for `S` a set, Lean uses\n"
"the notation `x ‚àà S` to mean that `x` is an element `S`.\n"
"\n"
"Click \"Start ‚Üí\" to continue."
msgstr ""

#: Game
msgid "The Filter Game"
msgstr ""

#: Game
msgid "# Welcome to the Filter Game\n"
"\n"
"## What is this game?\n"
"\n"
"There's a mathematical object called a *filter*. It doesn't get much love.\n"
"It's not often taught in an undergraduate degree. Furthermore, there are\n"
"bad ways to teach it, which can end up with you being more confused than\n"
"when you started. Indeed, the author of this game was confused about filters\n"
"for many years.\n"
"\n"
"This game is an attempt to explain filters in an intuitive way, as\n"
"\"generalised sets\". If you have been brainwashed by the textbook\n"
"approach to mathematics, you'll know that infinity is not a number,\n"
"that `dy/dx` doesn't mean `dy` divided by `dx` because `dx` isn't\n"
"a number, and that `0.999999999999999... = 1` because the difference\n"
"between them is infinitely small, and there are no infinitely small\n"
"numbers apart from `0`. Well, filters let you recover these intuitive\n"
"ideas in a rigorous way which doesn't lead to contradictions.\n"
"\n"
"## What are the prerequisites for playing?\n"
"\n"
"First, there are some mathematical prerequisites. You will need to know\n"
"about the abstract concepts of sets and subsets, and functions between sets.\n"
"You don't need much more than that. You can learn about these ideas\n"
"in any first course or textbook on abstract mathematics, for example\n"
"Martin Liebeck's book \"A Concise Introduction to Pure Mathematics\".\n"
"\n"
"And then there are some Lean prerequisites. Lean is an interactive\n"
"theorem prover, and this game is written in Lean; you can see\n"
"the source code to the game [here](https://github.com/kbuzzard/FilterGame)\n"
"on GitHub, and even clone it yourself and add your own levels if you want.\n"
"In this game I will assume you know the following basic Lean tactics:\n"
"**TODO** fill these in. If you don't know these tactics, then you could\n"
"try playing a few worlds in the [Natural Number Game](https://adam.math.hhu.de/#/g/leanprover-community/nng4).\n"
"If you've platyed through Tutorial World, Addition World and Implication World in that\n"
"game, then you know enough about Lean to play the Filter Game.\n"
"\n"
"## Getting started\n"
"\n"
"If you satisfy the prerequisites, get started by clicking on `Set World`!"
msgstr ""

#: Game
msgid "Version 0.1.0: experimental prerelease.\n"
"\n"
"## History\n"
"\n"
"The Filter Game has been a long time coming. I (Kevin Buzzard)\n"
"started experimenting with it in about 2020. The first Lean 4 project\n"
"I ever embarked on in 2021 was some Filter Game levels (I had to define\n"
"a filter in Lean 4 as part of it!). I then supervised a second\n"
"year group project on filters in 2023, and Billy Miao put together\n"
"a preliminary version (in Lean 3) as part of the project. I thank\n"
"Billy and the other group members **TODO** for their thoughts on\n"
"how things should be put together.\n"
"\n"
"What finally pushed this game into something which I felt was finally\n"
"ready, was the London Mathematical Society, who invited me to give\n"
"a course as part of their 2024 Summer School at the University of Essex.\n"
"I chose to give a course on filters, and made this game as part of\n"
"the learning experience for the students."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
